/* DSblock model generated by Dymola from Modelica model motor_with_elastic_loads
 Dymola Version 2018 FD01 (64-bit), 2017-10-11 translated this at Sun Jan 27 14:38:39 2019

   */

#include <matrixop.h>
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#define NX_    6
#define NX2_   0
#define NU_    1
#define NY_    1
#define NW_    26
#define NP_    9
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ 1061615805
#define NHash2_ 1459459582
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    33
#define SizePre_ 0
#define SizeEq_ 3
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 0
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="motor_with_elastic_loads";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=0;
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[12]={4 , 3 , 1 , 2 , 3 , 1 , 4 , 1 , 5 , 1 , 6 , 0};
DYMOLA_STATIC int QJacobianGC_[25]={
2 , 3 , 0 , 3 , 0 , 3 , 0 , 4 , 4 , 4 , 0 , 4 , 0 , 0 , 0 , 5 , 0 , 5 , 0 , 0 , 0
   , 6 , 6 , 6 , 0};
DYMOLA_STATIC double QJacobianCD_[7]={0  , 44 , 55 , 66 , 70 , 72 , 72};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,0) = false;
DYNX(W_,3) = 3;
DYNX(W_,4) = 0.0001;
DYNX(W_,5) = 4;
DYNX(W_,6) = false;
DYNX(W_,11) = 3;
DYNX(W_,16) = 3;
DYNX(W_,19) = 0.0001;
DYNX(W_,20) = 4;
DYNX(W_,21) = false;
DYNX(W_,15) = 0;
DYNX(W_,1) = 0;
DYNX(W_,25) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(F_,3) = 0;
DYNX(F_,5) = 0;
#endif
InitialSection
InitialStartSection
InitialSection
DefaultSection
InitializeData(0)
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection
DYNX(W_,13) = DYNX(X_,3)+DYNX(X_,1);
DYNX(Y_,0) = DYNX(X_,5)+DYNX(W_,13);

DynamicsSection
DYNX(W_,8) = DYNX(DP_,1)*(DYNX(X_,2)-DYNX(DP_,3));
DYNX(W_,9) = DYNX(DP_,2)*DYNX(X_,3);
DYNX(W_,2) = DYNX(W_,8)+DYNX(W_,9);
 /* Linear system of equations to solve. */
DYNX(F_,1) = RememberSimple_(DYNX(F_,1), 0);
SolveScalarLinearParametric(DYNX(DP_,0),"motor_inertia.J", DYNX(U_,0)+DYNX(W_,2),
  "u+motor_inertia.flange_b.tau", DYNX(F_,1),"der(motor_inertia.w)");
 /* End of Equation Block */ 

DYNX(F_,0) = DYNX(X_,1);
DYNX(W_,23) = DYNX(DP_,6)*(DYNX(X_,4)-DYNX(DP_,8));
DYNX(W_,24) = DYNX(DP_,7)*DYNX(X_,5);
DYNX(W_,10) = DYNX(W_,23)+DYNX(W_,24);
 /* Linear system of equations to solve. */
DYNX(W_,18) = RememberSimple_(DYNX(W_,18), 1);
SolveScalarLinearParametric(DYNX(DP_,5),"inertia2.J",  -DYNX(W_,10),
  " -inertia1.flange_b.tau", DYNX(W_,18),"der(inertia2.w)");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
DYNX(W_,14) = RememberSimple_(DYNX(W_,14), 2);
SolveScalarLinearParametric(DYNX(DP_,4),"inertia1.J", DYNX(W_,10)-DYNX(W_,2),
  "inertia1.flange_b.tau-motor_inertia.flange_b.tau", DYNX(W_,14),
  "der(inertia1.w)");
 /* End of Equation Block */ 

DYNX(F_,5) = DYNX(W_,18)-DYNX(W_,14);
DYNX(F_,4) = DYNX(X_,5);
DYNX(F_,2) = DYNX(X_,3);
DYNX(F_,3) = DYNX(W_,14)-DYNX(F_,1);

AcceptedSection1

AcceptedSection2
DYNX(W_,12) = DYNX(X_,2)+DYNX(X_,0);
DYNX(W_,17) = DYNX(X_,4)+DYNX(W_,12);
DYNX(W_,7) = DYNX(W_,9)*DYNX(X_,3);
DYNX(W_,22) = DYNX(W_,24)*DYNX(X_,5);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("torque.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("torque.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor_inertia.phi", 1, 1, 0, 4)
DeclareAlias2("torque.flange.tau", "Cut torque in the flange [N.m]", "u", -1, 2,\
 0, 132)
DeclareVariable("torque.phi_support", "Absolute angle of support flange [rad|deg]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("torque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "u", 1, 2, 0, 0)
DeclareAlias2("motor_inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor_inertia.phi", 1, 1, 0, 4)
DeclareAlias2("motor_inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"u", 1, 2, 0, 132)
DeclareAlias2("motor_inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor_inertia.phi", 1, 1, 0, 4)
DeclareVariable("motor_inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("motor_inertia.J", "Moment of inertia [kg.m2]", 0, 1, 0.0,\
1E+100,0.0,0,560)
DeclareVariable("motor_inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareState("motor_inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 0, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("motor_inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("motor_inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 1, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("motor_inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor_inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "motor_inertia.der(w)", 1, 6, 1, 0)
DeclareParameter("springDamper.c", "Spring constant [N.m/rad]", 1, 0.5, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("springDamper.d", "Damping constant [N.m.s/rad]", 2, 0.01, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("springDamper.phi_rel0", "Unstretched spring angle [rad|deg]", 3,\
 0, 0.0,0.0,0.0,0,560)
DeclareState("springDamper.phi_rel", "Relative rotation angle (= flange_b.phi - flange_a.phi) [rad|deg]",\
 2, 0, 0.0,0.0,0.0001,0,560)
DeclareDerivative("springDamper.der(phi_rel)", "der(Relative rotation angle (= flange_b.phi - flange_a.phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("springDamper.w_rel", "Relative angular velocity (= der(phi_rel)) [rad/s]",\
 3, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("springDamper.der(w_rel)", "der(Relative angular velocity (= der(phi_rel))) [rad/s2]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("springDamper.a_rel", "Relative angular acceleration (= der(w_rel)) [rad/s2]",\
 "springDamper.der(w_rel)", 1, 6, 3, 0)
DeclareAlias2("springDamper.tau", "Torque between flanges (= flange_b.tau) [N.m]",\
 "motor_inertia.flange_b.tau", 1, 5, 2, 0)
DeclareAlias2("springDamper.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor_inertia.phi", 1, 1, 0, 4)
DeclareAlias2("springDamper.flange_a.tau", "Cut torque in the flange [N.m]", \
"motor_inertia.flange_b.tau", -1, 5, 2, 132)
DeclareAlias2("springDamper.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia1.phi", 1, 5, 12, 4)
DeclareAlias2("springDamper.flange_b.tau", "Cut torque in the flange [N.m]", \
"motor_inertia.flange_b.tau", 1, 5, 2, 132)
DeclareVariable("springDamper.phi_nominal", "Nominal value of phi_rel (used for scaling) [rad|rad]",\
 0.0001, 0.0,1E+100,0.0,0,513)
DeclareVariable("springDamper.stateSelect", "Priority to use phi_rel and w_rel as states [:#(type=StateSelect)]",\
 4, 1.0,5.0,0.0,0,1541)
DeclareVariable("springDamper.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("springDamper.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("springDamper.tau_c", "Spring torque [N.m]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("springDamper.tau_d", "Damping torque [N.m]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("inertia1.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia1.phi", 1, 5, 12, 4)
DeclareAlias2("inertia1.flange_a.tau", "Cut torque in the flange [N.m]", \
"motor_inertia.flange_b.tau", -1, 5, 2, 132)
DeclareAlias2("inertia1.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia1.phi", 1, 5, 12, 4)
DeclareVariable("inertia1.flange_b.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareParameter("inertia1.J", "Moment of inertia [kg.m2]", 4, 1, 0.0,1E+100,0.0,\
0,560)
DeclareVariable("inertia1.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("inertia1.phi", "Absolute rotation angle of component [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inertia1.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "inertia1.w", 1, 5, 13, 0)
DeclareVariable("inertia1.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inertia1.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inertia1.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "inertia1.der(w)", 1, 5, 14, 0)
DeclareAlias2("inertia2.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia2.phi", 1, 5, 17, 4)
DeclareAlias2("inertia2.flange_a.tau", "Cut torque in the flange [N.m]", \
"inertia1.flange_b.tau", -1, 5, 10, 132)
DeclareAlias2("inertia2.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia2.phi", 1, 5, 17, 4)
DeclareVariable("inertia2.flange_b.tau", "Cut torque in the flange [N.m]", 0, \
0.0,0.0,0.0,0,777)
DeclareParameter("inertia2.J", "Moment of inertia [kg.m2]", 5, 1, 0.0,1E+100,0.0,\
0,560)
DeclareVariable("inertia2.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("inertia2.phi", "Absolute rotation angle of component [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inertia2.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "y", 1, 3, 0, 0)
DeclareAlias2("inertia2.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 "y", 1, 3, 0, 0)
DeclareVariable("inertia2.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inertia2.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "inertia2.der(w)", 1, 5, 18, 0)
DeclareParameter("springDamper1.c", "Spring constant [N.m/rad]", 6, 0.5, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("springDamper1.d", "Damping constant [N.m.s/rad]", 7, 0.01, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("springDamper1.phi_rel0", "Unstretched spring angle [rad|deg]",\
 8, 0, 0.0,0.0,0.0,0,560)
DeclareState("springDamper1.phi_rel", "Relative rotation angle (= flange_b.phi - flange_a.phi) [rad|deg]",\
 4, 0, 0.0,0.0,0.0001,0,560)
DeclareDerivative("springDamper1.der(phi_rel)", "der(Relative rotation angle (= flange_b.phi - flange_a.phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("springDamper1.w_rel", "Relative angular velocity (= der(phi_rel)) [rad/s]",\
 5, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("springDamper1.der(w_rel)", "der(Relative angular velocity (= der(phi_rel))) [rad/s2]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("springDamper1.a_rel", "Relative angular acceleration (= der(w_rel)) [rad/s2]",\
 "springDamper1.der(w_rel)", 1, 6, 5, 0)
DeclareAlias2("springDamper1.tau", "Torque between flanges (= flange_b.tau) [N.m]",\
 "inertia1.flange_b.tau", 1, 5, 10, 0)
DeclareAlias2("springDamper1.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia1.phi", 1, 5, 12, 4)
DeclareAlias2("springDamper1.flange_a.tau", "Cut torque in the flange [N.m]", \
"inertia1.flange_b.tau", -1, 5, 10, 132)
DeclareAlias2("springDamper1.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia2.phi", 1, 5, 17, 4)
DeclareAlias2("springDamper1.flange_b.tau", "Cut torque in the flange [N.m]", \
"inertia1.flange_b.tau", 1, 5, 10, 132)
DeclareVariable("springDamper1.phi_nominal", "Nominal value of phi_rel (used for scaling) [rad|rad]",\
 0.0001, 0.0,1E+100,0.0,0,513)
DeclareVariable("springDamper1.stateSelect", "Priority to use phi_rel and w_rel as states [:#(type=StateSelect)]",\
 4, 1.0,5.0,0.0,0,1541)
DeclareVariable("springDamper1.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("springDamper1.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("springDamper1.tau_c", "Spring torque [N.m]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("springDamper1.tau_d", "Damping torque [N.m]", 0.0, 0.0,0.0,0.0,\
0,2560)
DeclareAlias2("speedSensor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia2.phi", 1, 5, 17, 4)
DeclareAlias2("speedSensor.flange.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "y", 1, 3, 0, 4)
DeclareVariable("speedSensor.flange.tau", "Cut torque in the flange [N.m]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("speedSensor.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "y", 1, 3, 0, 0)
DeclareInput("u", "[N.m:#(prefix=input)]", 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("y", "[rad/s]", 0, 0.0, 0.0,0.0,0.0,0,512)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(W_,14), 0.0, 2);
DoRemember_(DYNX(W_,18), 0.0, 1);
DoRemember_(DYNX(F_,1), 0.0, 0);
EndEqBlock
EndDataBlock
